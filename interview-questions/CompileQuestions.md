# CMake 也能增量编译，为什么还要用 Bazel？
## CMake 本身不是编译器，也不是构建系统，它只是「生成」构建文件的工具。
CMake 负责生成 Makefile / Ninja / Visual Studio 工程等，
真正执行增量编译的是底层的 Make/Ninja/IDE，而不是 CMake 自己。

Bazel 是完整的构建系统，自己管理依赖关系、调度编译任务，它天生自带强大的增量编译能力。

有自己的缓存机制。

有更智能的依赖推导（比 Ninja 还要细粒度）。

支持分布式构建（比如远程缓存、远程编译）。

简单说：

CMake 是一个生成器，自己不编译。

Bazel 是一个编译执行系统，全套自己干。

## 工程规模越大，优势越明显。
小项目：CMake + Ninja 足够了，快也简单。

大项目（比如成千上万源文件，多模块依赖）：

Bazel 可以做到只编译真正改动的很小一部分。

支持跨语言构建（C++、Java、Python 混合）。

自带分布式缓存，大幅减少重复构建时间。

因此像 Google、Meta 这种超大型项目都用 Bazel，不用 CMake。

## 总结版回答示例（面试场景说话版）
CMake 本身不直接负责增量编译，它主要生成 Ninja 或 Makefile，然后由这些工具去做增量编译。
而 Bazel 是一个完整的构建系统，内置了更智能的依赖管理和远程缓存机制。对于大型工程来说，Bazel 在增量编译、缓存管理、分布式构建上的能力远远强于传统的 CMake+Make。
所以，在代码规模、模块复杂度提升之后，用 Bazel 可以显著提高开发体验和构建效率。