# 嵌入式软件开发（网络）岗位面试标准答案整理

## 一、C语言与嵌入式基础

### 1. 指针与数组的区别？

数组名是一个常量指针，表示数组首元素的地址；

指针可以指向任意地址，数组不能被重新赋值；

sizeof(array) 是整个数组大小，而 sizeof(pointer) 是指针大小。

### 2. volatile 的作用？

告诉编译器变量可能在程序外部被修改（如中断、外设）；

禁止编译器优化，避免寄存器缓存；

常用于硬件寄存器、状态标志位等。

### 3. 如何防止野指针？

指针初始化为 NULL；

使用后及时置 NULL；

避免返回栈内局部变量地址；

使用内存检查工具（如 valgrind）。

### 4. static 关键字的作用？

局部变量：延长生命周期，全局可见但局部作用域；

全局变量：限制访问范围，仅当前文件可见；

函数：仅在当前文件中可调用。

### 5. 结构体对齐？

结构体成员按最大成员对齐；

可使用 __attribute__((packed)) 控制对齐方式；

对齐影响内存占用和硬件访问效率。

### 6. C语言常见内存错误有哪些？

使用未初始化的指针；

释放未分配或重复释放内存；

越界访问数组；

栈溢出、堆溢出。

### 7. C语言中深拷贝与浅拷贝的区别？

浅拷贝：仅复制指针地址，两个对象共享一块内存；

深拷贝：复制实际数据，为每个对象分配独立内存。

### 8. 常见链表操作有哪些考点？

单链表翻转；

检测环（快慢指针）；

合并两个有序链表；

找中间节点、倒数第K个节点。

### 高频面试问题拓展：

static 与 extern 的结合用法？

结构体指针与指针数组的区别？

union 的作用及使用场景？

如何手动实现 memcpy 函数？

C语言中 inline 函数与宏的异同？

指针和多级指针、函数指针

## more
### malloc / calloc / realloc / free 的区别，内存泄漏场景

malloc、calloc、realloc 和 free。malloc 是按指定字节数分配内存，初始值不确定；calloc 也分配内存，但会把内存初始化为 0，还可以指定元素个数和每个元素大小。realloc 用于调整之前分配内存块的大小。而 free 就是释放已经分配的内存，让内存可以被再次使用，防止内存泄漏。它们在内存管理中各司其职哦。

## const 的各种组合：const int*、int* const 等

在 C 和 C++ 里，const 写在类型名前面和变量名前面，有时候效果是一样的，但含义稍有不同。写在类型名前，强调的是这个类型的对象是常量，比如 const int num，就是说 num 是一个常量整数。写在变量名前，更多是强调这个变量所指向的内容是常量，像 int const* ptr，意思是 ptr 指向的整数是常量，不能通过 ptr 去修改那个整数的值。但 ptr 本身可以指向其他地方。如果是 const int* const ptr，这就表示 ptr 本身不能再指向其他地方，而且它指向的值也不能改。你在实际代码里遇到过因为 const 位置不同而出错的情况吗？

## 字节序问题（endianness）

字节序就是数据在内存中存储的顺序。有大端和小端两种。大端序是高位字节存低地址，就像按从左到右正常顺序写数字。小端序相反，低位字节存低地址。比如整数 1234，十六进制是 0x04D2，大端序存储就是 04 D2，小端序则是 D2 04。不同硬件架构可能采用不同字节序，网络通信等场景要注意处理，不然数据可能会错乱。

## 写一个安全的 strcpy 替代函数

```c
#include <stdio.h>
#include <string.h>

void safe_strcpy(char *dest, const char *src, size_t size) {
    strncpy(dest, src, size);
    if (strlen(src) < size) {
        dest[strlen(src)] = '\0';
    } else {
        dest[size - 1] = '\0';
    }
}

int main() {
    char dest[10];
    const char src[] = "hello";
    safe_strcpy(dest, src, sizeof(dest));
    printf("%s\n", dest);
    return 0;
}
```