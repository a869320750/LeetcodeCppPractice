# 0.自我介绍
您好，我叫XXX，本科毕业于XXX大学XXX专业，拥有大约5年C++开发经验。

我此前在华为和宝钢工程工作过，期间主要参与了多个中大型项目，经历了从外包OD转为正式员工的全过程，对大规模软件项目开发流程、协作机制，以及高强度开发环境有比较深刻的认识。

我的工作重心主要集中在后端开发、数据处理以及性能优化方向，平时也会负责部分脚本编写和系统调优工作。熟悉Linux开发环境，擅长使用C++（包括C++11/14标准），掌握常用的数据结构与算法，同时对多线程编程、网络编程也有较扎实的实战经验。

在具体项目中，比如负责过分布式集群管理模块的开发与优化，快速准确高质量交付业务代码，稳定性也得到了明显增强；也曾主导过编译器替换项目的端到端开发，从需求对接到代码落地到性能测试，独立完成了全流程交付。

此外，我个人也有持续提升自己的习惯，目前正在系统性复习算法与数据结构，保持对底层技术的热情和学习能力。

未来希望能够继续在后端开发方向深耕，参与到更多有挑战性的项目中，同时进一步提升自己的系统设计、架构能力。也非常期待能在贵公司这样的优秀平台上，与团队一起成长，共同创造高质量的产品。

以上是我的简单介绍，谢谢！


# 1. C++的四大类型转换？区别？
static_cast：编译期类型转换，常规转换（比如int转float）。
dynamic_cast：运行时类型检查，多用于多态场景。
const_cast：去除const属性或加const。
reinterpret_cast：底层位级别强制转换，极危险，打破类型安全。
🧠 关键术语：类型安全、运行时检查、位级别操作

# 2. 智能指针的原理？有哪些？
shared_ptr：引用计数管理资源，最后一个销毁时释放内存。
weak_ptr：观察者指针，解决循环引用。
unique_ptr：独占式所有权，不可拷贝，只能转移。
🧠 关键词：RAII、引用计数、资源独占

# 3. RAII是什么？作用？
资源获取即初始化，把资源的申请和释放绑定到对象生命周期。
自动管理内存/文件锁/网络连接等，防止资源泄露。
🧠 关键词：异常安全、生命周期绑定

# 4. 深拷贝和浅拷贝区别？为什么需要深拷贝？
浅拷贝：复制指针地址，多指针指向同一块内存。
深拷贝：复制内容本身，分配新的内存。
防止析构时出现重复释放。
🧠 关键词：堆资源管理、拷贝控制、三五法则

# 5. C++11的三大特性？
移动语义：避免不必要的拷贝，提高性能。
智能指针：标准化RAII管理。
Lambda表达式：匿名函数提升代码简洁度。
🧠 关键词：右值引用、std::move、临时对象优化

# 6. 左值右值、左值引用右值引用？
左值：有名字、可寻址。
右值：临时对象，不可寻址。
左值引用：绑定到左值。
右值引用：绑定到右值，用于资源转移（move语义）。
🧠 关键词：引用折叠、完美转发

# 7. STL容器内部原理？vector, map？
vector：动态数组，容量翻倍扩容（通常是2倍）。
map：基于红黑树（自平衡二叉搜索树）。
🧠 关键词：红黑树、扩容、O(logN)

# 8. 内存对齐是啥？为什么要有？
为了CPU访问效率和硬件要求，结构体成员按特定字节对齐。
避免跨字节访问造成性能下降。
🧠 关键词：内存填充、cache line优化

# 9. 多态原理？虚函数表（vtable）？
基类指针指向子类对象，通过虚函数实现动态绑定。
编译器在对象中隐藏了指向虚函数表的指针。
🧠 关键词：动态绑定、虚表指针(vptr)、运行时多态

# 10. 虚函数和纯虚函数区别？
虚函数：可以被子类重写，父类有默认实现。
纯虚函数：=0的函数，子类必须重写。

🧠 关键词：抽象类、接口规范

# 11. C++对象模型？
每个对象有自己的数据成员。
类的函数成员存在于代码段，不属于对象本身。
有虚函数的话，每个对象会有一份vptr指针。
🧠 关键词：对象布局、内存模型

# 12. 拷贝构造和赋值运算符有什么区别？
拷贝构造：用已有对象初始化新对象。
赋值运算符：把已有对象的值赋给已经存在的对象。
🧠 关键词：三大函数、复制控制

# 13. 什么是移动构造？什么时候触发？
移动构造：接收右值，偷取资源而不是复制。
触发场景：返回局部变量、临时对象初始化。
🧠 关键词：资源复用、提高性能

# 14. lambda表达式底层是什么？
编译器自动生成一个匿名类+operator()重载。
实质上是一个轻量的仿函数对象。
🧠 关键词：闭包对象、捕获列表

# 15. 函数模板和类模板？
函数模板：支持泛型函数。
类模板：支持泛型数据结构（比如vector<T>）。
🧠 关键词：泛型编程、模板实例化

# 16. 异常机制原理？
try-catch块捕获异常。
抛异常会调用栈展开，逐层调用析构函数清理资源。
🧠 关键词：异常安全、栈回溯

# 17. C++内存管理？new/delete和malloc/free区别？
new/delete：调用构造和析构函数，分配内存。
malloc/free：只负责分配和释放内存，不管对象生命周期。
🧠 关键词：内存分配器、对象生命周期

# 18. 静态成员变量、静态成员函数？
静态变量：类共享一份。
静态函数：不能访问非静态成员。
🧠 关键词：类级别数据、无this指针

# 19. volatile关键字？
告诉编译器变量随时可能被外部修改，防止优化。
🧠 关键词：内存屏障、编译器优化

# 20. C++线程库基础？
std::thread创建线程。
std::mutex实现互斥锁。
std::condition_variable实现线程同步。
🧠 关键词：线程安全、死锁预防

# 21. 宏定义、内联函数、模板的区别与应用场景
宏定义（#define）
    预处理器替换，简单粗暴，无类型检查。
    用来定义常量、条件编译、小片段代码替换。
    缺点：容易引发难以发现的错误，调试困难。
内联函数（inline）
    编译期展开，提高小函数调用性能，带类型检查。
    适合逻辑简单、调用频繁的小函数。
模板
    泛型编程，编译期生成不同类型的代码。
    适合实现类型无关的算法（如容器、排序等）。
总结口诀：
    「宏最快但最危险 → 内联平衡效率和安全 → 模板支持泛型复用」

# 22. 模板代码体积膨胀如何解决
常规方法：
    精简模板逻辑，不滥用模板。
    特化常见场景，减少过多实例化。
    尽可能将不必要的模板参数提取到非模板基类中。
高级方法：
    使用类型擦除（如 std::function、void*）减少模板实例数量。
    使用 Explicit Instantiation（显式实例化）减少重复生成。

# 23. 友元（friend）什么时候用、为什么少用
使用场景：
    重载操作符需要访问内部私有成员。
    两个或多个类高度耦合时，允许某个类访问另一个类的私有部分。
为什么少用：
    破坏封装性，增加耦合，降低模块可维护性和扩展性。
    简洁说法：友元是为了效率，牺牲了封装性，用的时候要慎重。

# 24. 内存泄漏、越界、野指针
内存泄漏：申请了堆内存，但没有释放，造成内存浪费。
内存越界：访问了非法的内存地址，比如数组越界。
野指针：指针指向已被释放或未初始化的内存。

# 25. new 和 malloc 区别
new：
    C++专有，调用构造函数，类型安全。
    出现异常时自动抛出异常（bad_alloc）。
malloc：
    C标准库函数，仅分配内存，不调用构造函数。
    返回 void*，需要手动强制类型转换。
释放：
    new 对应 delete，malloc 对应 free。